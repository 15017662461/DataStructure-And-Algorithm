一、算法复杂度
      1.空间复杂度S(b)
         ①概念：根据算法写成的程序在执行时占用储存单元的长度
         ②递归算法每一次递归都会占用一定的空间内存，而for循环则不会
      2.时间复杂度T(n)
         ①概念：根据算法写成的程序在执行时耗费时间的长度

复杂度：忽略系数，忽略常数项，取最高次项
1<logN<n<nlogN<n平方<n立方<n的k次方<2的k次方<n!
logN复杂度常见于while(i<n){i = 2*i}中
n复杂度常见于for(int i = 0;i < n ; i ++)中
nlogN复杂度常见于for(int i = 0;i < n ; i ++){while(i<n){i = 2*i}}中
n平方、立方、k次方常见于多层for嵌套中

二、排序算法
      1.冒泡排序
         先将数组相邻的两位两两比较，将最大的放在数组的最后面，然后再两两比较，将次最大的放在倒数第二个
         以此类推直到完成
      2.选择排序
         选择出数组最小的放在第一位，次最小的放在第二位......以此类推
      3.插入排序
         先默认将第一位放好，然后根据大小顺序依次插入第二个第三个.....
      4.希尔排序
         将数组分组，组内进行插入排序，然后减少分组的组数，继续进行组内排序，最终形成一组
      5.快速排序
         先选择一个数，将小于这个数的放在左边，大于的放在右边，然后对左右再选择中间数....（递归）
      6.归并排序
         先将数组分开成一个个数，再两两合并成数组，数组内有序，接着继续两两合并最终完成（递归）
      7.基数排序
         先按照个位数字大小将每一个数放入对应的（0~10）桶中，然后依次拿出；再按照上面的顺序，根据
         十位数大小将每一个数放入对应的桶中，拿出......
      8.堆排序
         采用顺序二叉树，先将数组构成大/小顶堆的顺序二叉树(父节点大于/小于等于子节点)，然后堆顶就是最大的，
         取出堆顶放在最后，在对顺序二叉树进行处理，取出次大的....以此类推（类似选择排序）
         顺序二叉树的最后一个非叶子结点的序号为：arr.length/2-1,我们从最后一个非子节点开始，让每一个父节点
         都大于等于子节点，这样得到的根节点就是数组最大的那一位

三、查找算法
      1.线性查找
        这种查找不要求数组是否有序，直接遍历数组，将查找的数的下标返回
      2.二分查找
        这种查找要求数组是有序的（这里默认为从小到大排序）
        先将数组一分为二，判断中间的值与要查找的值的大小，如果中间的值大于要查找的值，继续向左一分为二
        如果中间的值小于要查找的值，则继续向右一分为二查找（递归）
      3.插值查找
        这种查找要求数组是有序的（这里默认为从小到大排序）
        与二分查找类似，只不过将中间的下标修改为：left + (right - left) * (findVal - arr[left]) / (arr[right]-arr[left])
      4.斐波那契查找
        这种查找要求数组是有序的（这里默认为从小到大排序）
        与二分查找类似，将mid下标修改为：left+F(k-1)-1           F（k-1）表示斐波那契数列的第k-1个数
        如果数组长度不等于F(k)-1，我们需要将长度增加至F(k)-1，增加的数值全部为最后一个数即可
        延长数组可以使用Arrays.copyOf(原数组，延长后的长度)，不够的部分会用0填充，之后替换即可

四、顺序存储二叉树、二叉排序树、平衡二叉树
      1.二叉排序树转平衡二叉树之左旋转：（条件是右子树高度减去左子树高度大于1）
         ①创建新的节点，以当前根节点的值为值
         ②把新的节点的左子树设置为当前节点的左子树
         ③把新的节点的右子树设置成当前节点的右子树的左子树
         ④把当前节点的值替换成右子节点的值
         ⑤把当前节点的右子树设置成当前节点的右子树的右子树
         ⑥把当前节点的左子树设置为新的节点
      
      2.二叉排序树转平衡二叉树之右旋转：（条件是左子树高度减去右子树高度大于1）
         ①创建新的节点，以当前根节点的值为值
         ②把新的节点的右子树设置为当前节点的右子树
         ③把新的节点的左子树设置成当前节点的左子树的右子树
         ④把当前节点的值替换成左子节点的值
         ⑤把当前节点的左子树设置成当前节点的左子树的左子树
         ⑥把当前节点的右子树设置为新的节点
      
      3.二叉排序树转平衡二叉树之双旋转：
         ①首先判断右子树高度减去左子树高度大于1，大于1时，
            如果右子树的左子树的高度大于它的右子树的高度，需要对当前节点的右节点进行右旋转之后再进行左旋转
            如果右子树的左子树的高度不大于它的右子树的高度，直接进行左旋转
         ②再判断左子树高度减去右子树的高度的值大于1，大于1时，
            如果左子树的右子树的高度大于它的左子树的高度，需要对当前节点的左节点进行左旋转之后再进行右旋转
             如果左子树的右子树的高度不大于它的左子树的高度，直接进行右旋转
         
